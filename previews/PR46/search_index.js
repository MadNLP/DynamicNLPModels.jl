var documenterSearchIndex = {"docs":
[{"location":"guide/#Getting-Started","page":"Quick Start","title":"Getting Started","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"DynamicNLPModels.jl takes user defined data to construct a linear MPC problem of the form","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"beginaligned\nmin_s u v  s_N^top Q_f s_N + frac12 sum_i = 0^N-1 left beginarrayc s_i  u_i endarray right^top left beginarraycc Q  S  S^top  R endarray right left beginarrayc s_i  u_i endarray right\n          textrmst s_i+1 = As_i + Bu_i + w_i quad forall i = 0 1 cdots N - 1 \n           u_i = Ks_i + v_i quad  forall i = 0 1 cdots N - 1 \n           g^l le E s_i + F u_i le g^u quad forall i = 0 1 cdots N - 1\n           s^l le s_i le s^u quad forall i = 0 1 cdots N \n           u^l le u_i le u^u quad forall i = 0 1 cdots N - 1\n           s_0 = bars\nendaligned","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"This data is stored within the struct LQDynamicData, which can be created by passing the data s0, A, B, Q, R and N to the constructor as in the example below. ","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"using DynamicNLPModels, Random, LinearAlgebra\n\nQ  = 1.5 * Matrix(I, (3, 3))\nR  = 2.0 * Matrix(I, (2, 2))\nA  = rand(3, 3)\nB  = rand(3, 2)\nN  = 5\ns0 = [1.0, 2.0, 3.0]\n\nlqdd = LQDynamicData(s0, A, B, Q, R, N; **kwargs)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"LQDynamicData contains the following fields. All fields after R are keyword arguments:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"ns: number of states (determined from size of Q)\nnu: number of inputs (determined from size of R)\nN : number of time steps\ns0: a vector of initial states\nA : matrix that is multiplied by the states that corresponds to the dynamics of the problem. Number of columns is equal to ns\nB : matrix that is multiplied by the inputs that corresonds to the dynamics of the problem. Number of columns is equal to nu\nQ : objective function matrix for system states from 0 1 cdots (N - 1)\nR : objective function matrix for system inputs from 0 1 cdots (N - 1)\nQf: objective function matrix for system states at time N\nS : objective function matrix for system states and inputs\nE : constraint matrix multiplied by system states. Number of columns is equal to ns\nF : constraint matrix multiplied by system inputs. Number of columns is equal to nu\nK : feedback gain matrix. Used to ensure numerical stability of the condensed problem. Not necessary within the sparse problem\nw : constant term within dynamic constraints. At this time, this is the only data that is time varying. This vector must be length ns * N, where each set of ns entries corresponds to that time (i.e., entries 1:ns correspond to time 0, entries (ns + 1):(2 * ns) corresond to time 1, etc.)\nsl : lower bounds on state variables\nsu : upper bounds on state variables \nul : lower bounds on ipnut variables\nuu : upper bounds on input variables\ngl : lower bounds on the constraints Es_i + Fu_i\ngu : upper bounds on the constraints Es_i + Fu_i","category":"page"},{"location":"guide/#SparseLQDynamicModel","page":"Quick Start","title":"SparseLQDynamicModel","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"A SparseLQDynamicModel can be created by either passing LQDynamicData to the constructor or passing the data itself, where the same keyword options exist which can be used for LQDynamicData. ","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"sparse_lqdm = SparseLQDynamicModel(lqdd)\n\n# or \n\nsparse_lqdm = SparseLQDynamicModel(s0, A, B, Q, R, N; **kwargs)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The SparseLQDynamicModel contains four fields:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"dynamic_data which contains the LQDynamicData\ndata which is the QPData from QuadraticModels.jl. This object also contains the following data:\nH which is the Hessian of the linear MPC problem \nA which is the Jacobian of the linear MPC problem such that textrmlcon le A z le textrmucon\nc which is the linear term of a quadratic objective function\nc0 which is the constant term of a quadratic objective function\nmeta which contains the NLPModelMeta for the problem from NLPModels.jl\ncounters which is the Counters object from NLPModels.jl","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"!!! Note     The SparseLQDynamicModel requires that all matrices in the LQDynamicData be the same type. It is recommended that the user be aware of how to most efficiently store their data in the Q, R, A, and B matrices as this impacts how efficiently the SparseLQDynamicModel is constructed. When Q, R, A, and B are sparse, building the SparseLQDynamicModel is much faster when these are passed as sparse rather than dense matrices. ","category":"page"},{"location":"guide/#DenseLQDynamicModel","page":"Quick Start","title":"DenseLQDynamicModel","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The DenseLQDynamicModel eliminates the states within the linear MPC problem to build an equivalent optimization problem that is only a function of the inputs. This can be particularly useful when the number of states is large compared to the number of inputs.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"A DenseLQDynamicModel can be created by either passing LQDynamicData to the constructor or passing the data itself, where the same keyword options exist which can be used for LQDynamicData. ","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"dense_lqdm = DenseLQDynamicModel(lqdd)\n\n# or \n\ndense_lqdm = DenseLQDynamicModel(s0, A, B, Q, R, N; **kwargs)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The DenseLQDynamicModel contains five fields:","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"dynamic_data which contains the LQDynamicData\ndata which is the QPData from QuadraticModels.jl. This object also contains the following data:\nH which is the Hessian of the condensed linear MPC problem \nA which is the Jacobian of the condensed linear MPC problem such that textrmlcon le A z le textrmucon\nc which is the linear term of the condensed linear MPC problem \nc0 which is the constant term of the condensed linear MPC problem\nmeta which contains the NLPModelMeta for the problem from NLPModels.jl\ncounters which is the Counters object from NLPModels.jl\nblocks which contains the data needed to condense the model and then to update the condensed model when s0 is reset. ","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The DenseLQDynamicModel is formed from dense matrices, and this dense system can be solved on a GPU using MadNLP.jl and MadNLPGPU.jl For an example script for performing this, please see the the examples directory of the main repository.","category":"page"},{"location":"guide/#API-functions","page":"Quick Start","title":"API functions","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"An API has been created for working with LQDynamicData and the sparse and dense models. All functions can be seen in the API Manual section. However, we give a short overview of these functions here. ","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"reset_s0!(LQDynamicModel, new_s0): resets the model in place with a new s0 value. This could be called after each sampling period in MPC to reset the model with a new measured value\nget_s(solver_ref, LQDynamicModel): returns the optimal solution for the states from a given solver reference\nget_u(solver_ref, LQDynamicModel): returns the optimal solution for the inputs from a given solver reference; when K is defined, the solver reference contains the optimal v values rather than optimal u values, adn this function converts v to u and returns the u values\nget_*:  returns the data of * where * is an object within LQDynamicData\nset_*!: sets the value within the data of * for a given entry to a user defined value","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"api/#API-Manual","page":"API Manual","title":"API Manual","text":"","category":"section"},{"location":"api/","page":"API Manual","title":"API Manual","text":"Modules = [DynamicNLPModels]","category":"page"},{"location":"api/#DynamicNLPModels.DenseLQDynamicBlocks","page":"API Manual","title":"DynamicNLPModels.DenseLQDynamicBlocks","text":"Struct containing block matrices used for creating and resetting the DenseLQDynamicModel. A and B matrices are given in part by Jerez, Kerrigan, and Constantinides in section 4 of \"A sparse and condensed QP formulation for predictive control of LTI systems\" (doi:10.1016/j.automatica.2012.03.010). States are eliminated by the equation  x = Ax_0 + Bu + hatAw where  x = x_0^T x_1^T  x_N^T and u = u_0^T u_1^T  u_N-1^T\n\n\n\nA  : block A matrix given by Jerez et al. with n_s(N + 1) rows and ns columns\nB  : block B matrix given by Jerez et al. with n_s(N) rows and nu columns\nAw : length n_s(N + 1) vector corresponding to the linear term of the dynamic constraints\nh  : n_u(N) times n_s matrix for building the linear term of the objective function. Just needs to be\n\nmultiplied by s0.\n\nh01: ns x ns matrix for building the constant term fo the objective function. This can be found by\n\ntaking  s_0^T  h01  s_0\n\nh02: similar to h01, but one side is multiplied by Aw rather than by As0. This will just\n\nbe multiplied by s0 once\n\nh_constant : linear term in the objective function that arises from Aw. Not a function of s0\nh0_constant: constant term in the objective function that arises from Aw. Not a function of s0\nd  : length n_c(N) term for the constraint bounds corresponding to E and F. Must be multiplied by s0 and\n\nsubtracted from gl and gu. Equal to the blocks (E + FK) A (see Jerez et al.)\n\ndw : length n_c(N) term for the constraint bounds that arises from w. Equal to the blocks (E + FK) Aw\nKA : size n_u(N) x ns matrix. Needs to be multiplied by s0 and subtracted from ul and uu to update\n\nthe algebraic constraints corresponding to the input bounds\n\nKAw: similar to KA, but it is multiplied by Aw rather than A\n\nSee also reset_s0!\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicNLPModels.DenseLQDynamicModel-Union{Tuple{LQDynamicData{T, V, M}}, Tuple{MK}, Tuple{M}, Tuple{V}, Tuple{T}} where {T, V<:AbstractVector{T}, M<:AbstractMatrix{T}, MK<:Union{Nothing, AbstractMatrix{T}}}","page":"API Manual","title":"DynamicNLPModels.DenseLQDynamicModel","text":"DenseLQDynamicModel(dnlp::LQDynamicData; implicit = false)    -> DenseLQDynamicModel\nDenseLQDynamicModel(s0, A, B, Q, R, N; implicit = false ...) -> DenseLQDynamicModel\n\nA constructor for building a DenseLQDynamicModel <: QuadraticModels.AbstractQuadraticModel\n\nInput data is for the problem of the form\n\n    beginaligned\n        min frac12  sum_i = 0^N - 1(s_i^T Q s_i + 2 u_i^T S^T x_i + u_i^T R u_i) + frac12 s_N^T Q_f s_N \n        textrmst  s_i+1 = A s_i + B u_i + w_i  quad forall i=0 1  N-1 \n         u_i = Kx_i + v_i quad  forall i = 0 1  N - 1 \n         gl le E s_i + F u_i le gu quad forall i = 0 1  N-1\n         sl le s le su \n         ul le u le uu \n         s_0 = s0\n    endaligned\n\n\n\nData is converted to the form\n\nbeginaligned\n    min     frac12 z^T H z \n    textrmst   textrmlcon le Jz le textrmucon\n     textrmlvar le z le textrmuvar\nendaligned\n\nResulting H, J, h, and h0 matrices are stored within QuadraticModels.QPData as H, A, c, and c0 attributes respectively\n\nIf K is defined, then u variables are replaced by v variables. The bounds on u are transformed into algebraic constraints, and u can be queried by get_u and get_s within DynamicNLPModels.jl\n\nKeyword argument implicit = false determines how the Jacobian is stored within the QPData. If implicit = false, the full, dense Jacobian matrix is stored. If implicit = true, only the first nu columns of the Jacobian are stored with the Linear Operator LQJacobianOperator.\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.LQDynamicData","page":"API Manual","title":"DynamicNLPModels.LQDynamicData","text":"LQDynamicData{T,V,M,MK} <: AbstractLQDynData{T,V}\n\nA struct to represent the features of the optimization problem\n\n    beginaligned\n        min frac12  sum_i = 0^N - 1(s_i^T Q s_i + 2 u_i^T S^T x_i + u_i^T R u_i) + frac12 s_N^T Q_f s_N \n        textrmst  s_i+1 = A s_i + B u_i + w_i  quad forall i=0 1  N-1 \n         u_i = Kx_i + v_i quad  forall i = 0 1  N - 1 \n         g^l le E s_i + F u_i le g^u quad forall i = 0 1  N-1\n         s^l le s le s^u \n         u^l le u le u^u \n         s_0 = s0\n    endaligned\n\n\n\nAttributes include:\n\ns0: initial state of system\nA : constraint matrix for system states\nB : constraint matrix for system inputs\nQ : objective function matrix for system states from 0:(N-1)\nR : objective function matrix for system inputs from 0:(N-1)\nN : number of time steps\nQf: objective function matrix for system state at time N\nS : objective function matrix for system states and inputs\nns: number of state variables\nnu: number of input varaibles\nE : constraint matrix for state variables\nF : constraint matrix for input variables\nK : feedback gain matrix\n'w' : constant term for dynamic constraints\nsl: vector of lower bounds on state variables\nsu: vector of upper bounds on state variables\nul: vector of lower bounds on input variables\nuu: vector of upper bounds on input variables\ngl: vector of lower bounds on constraints\ngu: vector of upper bounds on constraints\n\nsee also LQDynamicData(s0, A, B, Q, R, N; ...)\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicNLPModels.LQDynamicData-Union{Tuple{MK}, Tuple{M}, Tuple{V}, Tuple{T}, Tuple{V, M, M, M, M, Any}} where {T, V<:AbstractVector{T}, M<:AbstractMatrix{T}, MK<:Union{Nothing, AbstractMatrix{T}}}","page":"API Manual","title":"DynamicNLPModels.LQDynamicData","text":"LQDynamicData(s0, A, B, Q, R, N; ...) -> LQDynamicData{T, V, M, MK}\n\nA constructor for building an object of type LQDynamicData for the optimization problem\n\n    beginaligned\n        min frac12  sum_i = 0^N - 1(s_i^T Q s_i + 2 u_i^T S^T x_i + u_i^T R u_i) + frac12 s_N^T Q_f s_N \n        textrmst  s_i+1 = A s_i + B u_i + w_i  quad forall i=0 1  N-1 \n         u_i = Kx_i + v_i quad  forall i = 0 1  N - 1 \n         gl le E s_i + F u_i le gu quad forall i = 0 1  N-1\n         sl le s le su \n         ul le u le uu \n         s_0 = s0\n    endaligned\n\n\n\ns0: initial state of system\nA : constraint matrix for system states\nB : constraint matrix for system inputs\nQ : objective function matrix for system states from 0:(N-1)\nR : objective function matrix for system inputs from 0:(N-1)\nN : number of time steps\n\nThe following attributes of the LQDynamicData type are detected automatically from the length of s0 and size of R\n\nns: number of state variables\nnu: number of input varaibles\n\nThe following keyward arguments are also accepted\n\nQf = Q: objective function matrix for system state at time N; dimensions must be ns x ns\nS  = nothing: objective function matrix for system state and inputs\nE  = zeros(eltype(Q), 0, ns)  : constraint matrix for state variables\nF  = zeros(eltype(Q), 0, nu)  : constraint matrix for input variables\nK  = nothing       : feedback gain matrix\nw  = zeros(eltype(Q), ns * N)     : constant term for dynamic constraints\nsl = fill(-Inf, ns): vector of lower bounds on state variables\nsu = fill(Inf, ns) : vector of upper bounds on state variables\nul = fill(-Inf, nu): vector of lower bounds on input variables\nuu = fill(Inf, nu) : vector of upper bounds on input variables\ngl = fill(-Inf, size(E, 1)) : vector of lower bounds on constraints\ngu = fill(Inf, size(E, 1))  : vector of upper bounds on constraints\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.LQJacobianOperator","page":"API Manual","title":"DynamicNLPModels.LQJacobianOperator","text":"LQJacobianOperator{T, V, M}\n\nStruct for storing the implicit Jacobian matrix. All data for the Jacobian can be stored in the first nu columns of J. This struct contains the needed data and storage arrays for calculating Jx, J^T x, and J^T Sigma J. Jx and J^T x are performed through extensions to LinearAlgebra.mul!().\n\n\n\nAttributes\n\ntruncated_jac1: Matrix of first nu columns of the Jacobian corresponding to Ax + Bu constraints\ntruncated_jac2: Matrix of first nu columns of the Jacobian corresponding to state variable bounds\ntruncated_jac3: Matrix of first nu columns of the Jacobian corresponding to input variable bounds\nN  : number of time steps\nnu : number of inputs\nnc : number of algebraic constraints of the form gl <= Es + Fu <= gu\nnsc: number of bounded state variables\nnuc: number of bounded input variables (if K is defined)\nSJ1: placeholder for storing data when calculating ΣJ\nSJ2: placeholder for storing data when calculating ΣJ\nSJ3: placeholder for storing data when calculating ΣJ\nH_sub_block: placeholder for storing data when adding J^T ΣJ to the Hessian\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicNLPModels.SparseLQDynamicModel-Union{Tuple{LQDynamicData{T, V, M}}, Tuple{MK}, Tuple{M}, Tuple{V}, Tuple{T}} where {T, V<:AbstractVector{T}, M<:AbstractMatrix{T}, MK<:Union{Nothing, AbstractMatrix{T}}}","page":"API Manual","title":"DynamicNLPModels.SparseLQDynamicModel","text":"SparseLQDynamicModel(dnlp::LQDynamicData)    -> SparseLQDynamicModel SparseLQDynamicModel(s0, A, B, Q, R, N; ...) -> SparseLQDynamicModel A constructor for building a SparseLQDynamicModel <: QuadraticModels.AbstractQuadraticModel Input data is for the problem of the form\n\n    beginaligned\n        min frac12  sum_i = 0^N - 1(s_i^T Q s_i + 2 u_i^T S^T x_i + u_i^T R u_i) + frac12 s_N^T Q_f s_N \n        textrmst  s_i+1 = A s_i + B u_i + w_i  quad forall i=0 1  N-1 \n         u_i = Kx_i + v_i quad  forall i = 0 1  N - 1 \n         gl le E s_i + F u_i le gu quad forall i = 0 1  N-1\n         sl le s le su \n         ul le u le uu \n         s_0 = s0\n    endaligned\n\n\n\nData is converted to the form\n\nbeginaligned\n    min     frac12 z^T H z \n    textrmst   textrmlcon le Jz le textrmucon\n     textrmlvar le z le textrmuvar\nendaligned\n\nResulting H and J matrices are stored as QuadraticModels.QPData within the SparseLQDynamicModel struct and variable and constraint limits are stored within NLPModels.NLPModelMeta\n\nIf K is defined, then u variables are replaced by v variables, and u can be queried by get_u and get_s within DynamicNLPModels.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.add_jtsj!-Union{Tuple{A}, Tuple{M}, Tuple{V}, Tuple{T}, Tuple{M, DynamicNLPModels.LQJacobianOperator{T, M, A}, V}, Tuple{M, DynamicNLPModels.LQJacobianOperator{T, M, A}, V, Number}, Tuple{M, DynamicNLPModels.LQJacobianOperator{T, M, A}, V, Number, Number}} where {T, V<:AbstractVector{T}, M<:AbstractMatrix{T}, A<:(AbstractArray{T})}","page":"API Manual","title":"DynamicNLPModels.add_jtsj!","text":"add_jtsj!(H::M, Jac::LQJacobianOperator{T, V, M}, Σ::V, alpha::Number = 1, beta::Number = 1)\n\nGenerates Jac' Σ Jac and adds it to the matrix H.\n\nalpha and beta are scalar multipliers such beta H + alpha Jac' Σ Jac is stored in H, overwriting the existing value of H\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_A-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_A","text":"get_A(LQDynamicData)\nget_A(SparseLQDynamicModel)\nget_A(DenseLQDynamicModel)\n\nReturn the value of A from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_B-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_B","text":"get_B(LQDynamicData)\nget_B(SparseLQDynamicModel)\nget_B(DenseLQDynamicModel)\n\nReturn the value of B from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_E-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_E","text":"get_E(LQDynamicData)\nget_E(SparseLQDynamicModel)\nget_E(DenseLQDynamicModel)\n\nReturn the value of E from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_F-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_F","text":"get_F(LQDynamicData)\nget_F(SparseLQDynamicModel)\nget_F(DenseLQDynamicModel)\n\nReturn the value of F from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_K-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_K","text":"get_K(LQDynamicData)\nget_K(SparseLQDynamicModel)\nget_K(DenseLQDynamicModel)\n\nReturn the value of K from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_N-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_N","text":"get_N(LQDynamicData)\nget_N(SparseLQDynamicModel)\nget_N(DenseLQDynamicModel)\n\nReturn the value of N from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_Q-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_Q","text":"get_Q(LQDynamicData)\nget_Q(SparseLQDynamicModel)\nget_Q(DenseLQDynamicModel)\n\nReturn the value of Q from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_Qf-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_Qf","text":"get_Qf(LQDynamicData)\nget_Qf(SparseLQDynamicModel)\nget_Qf(DenseLQDynamicModel)\n\nReturn the value of Qf from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_R-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_R","text":"get_R(LQDynamicData)\nget_R(SparseLQDynamicModel)\nget_R(DenseLQDynamicModel)\n\nReturn the value of R from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_S-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_S","text":"get_S(LQDynamicData)\nget_S(SparseLQDynamicModel)\nget_S(DenseLQDynamicModel)\n\nReturn the value of S from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_gl-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_gl","text":"get_gl(LQDynamicData)\nget_gl(SparseLQDynamicModel)\nget_gl(DenseLQDynamicModel)\n\nReturn the value of gl from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_gu-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_gu","text":"get_gu(LQDynamicData)\nget_gu(SparseLQDynamicModel)\nget_gu(DenseLQDynamicModel)\n\nReturn the value of gu from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_jacobian-Union{Tuple{DenseLQDynamicModel{T, V, M1, M2, M3, M4, MK}}, Tuple{MK}, Tuple{M4}, Tuple{M3}, Tuple{M2}, Tuple{M1}, Tuple{V}, Tuple{T}} where {T, V, M1, M2, M3, M4, MK}","page":"API Manual","title":"DynamicNLPModels.get_jacobian","text":"get_jacobian(lqdm::DenseLQDynamicModel) -> LQJacobianOperator\nget_jacobian(Jac::AdjointLinearOpeartor{T, LQJacobianOperator}) -> LQJacobianOperator\n\nGets the LQJacobianOperator from DenseLQDynamicModel (if the QPdata contains a LQJacobian Operator) or returns the LQJacobian Operator from the adjoint of the LQJacobianOperator\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_ns-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_ns","text":"get_ns(LQDynamicData)\nget_ns(SparseLQDynamicModel)\nget_ns(DenseLQDynamicModel)\n\nReturn the value of ns from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_nu-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_nu","text":"get_nu(LQDynamicData)\nget_nu(SparseLQDynamicModel)\nget_nu(DenseLQDynamicModel)\n\nReturn the value of nu from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_s-Union{Tuple{MK}, Tuple{M3}, Tuple{M2}, Tuple{M1}, Tuple{V}, Tuple{T}, Tuple{Any, SparseLQDynamicModel{T, V, M1, M2, M3, MK}}} where {T, V<:AbstractVector{T}, M1<:AbstractMatrix{T}, M2<:AbstractMatrix{T}, M3<:AbstractMatrix{T}, MK<:Union{Nothing, AbstractMatrix}}","page":"API Manual","title":"DynamicNLPModels.get_s","text":"gets(solutionref, lqdm::SparseLQDynamicModel) -> s <: vector gets(solutionref, lqdm::DenseLQDynamicModel) -> s <: vector\n\nQuery the solution s from the solver. If lqdm <: SparseLQDynamicModel, the solution is queried directly from solution_ref.solution If lqdm <: DenseLQDynamicModel, then solution_ref.solution returns u (if K = nothing) or v (if K <: AbstactMatrix), and s is found form transforming u or v into s using A, B, and K matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_s0-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_s0","text":"get_s0(LQDynamicData)\nget_s0(SparseLQDynamicModel)\nget_s0(DenseLQDynamicModel)\n\nReturn the value of s0 from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_sl-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_sl","text":"get_sl(LQDynamicData)\nget_sl(SparseLQDynamicModel)\nget_sl(DenseLQDynamicModel)\n\nReturn the value of sl from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_su-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_su","text":"get_su(LQDynamicData)\nget_su(SparseLQDynamicModel)\nget_su(DenseLQDynamicModel)\n\nReturn the value of su from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_u-Union{Tuple{MK}, Tuple{M3}, Tuple{M2}, Tuple{M1}, Tuple{V}, Tuple{T}, Tuple{Any, SparseLQDynamicModel{T, V, M1, M2, M3, MK}}} where {T, V<:AbstractVector{T}, M1<:AbstractMatrix{T}, M2<:AbstractMatrix{T}, M3<:AbstractMatrix{T}, MK<:AbstractMatrix{T}}","page":"API Manual","title":"DynamicNLPModels.get_u","text":"getu(solutionref, lqdm::SparseLQDynamicModel) -> u <: vector getu(solutionref, lqdm::DenseLQDynamicModel) -> u <: vector\n\nQuery the solution u from the solver. If K = nothing, the solution for u is queried from solution_ref.solution\n\nIf K <: AbstractMatrix, solution_ref.solution returns v, and get_u solves for u using the K matrix (and the A and B matrices if lqdm <: DenseLQDynamicModel)\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_ul-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_ul","text":"get_ul(LQDynamicData)\nget_ul(SparseLQDynamicModel)\nget_ul(DenseLQDynamicModel)\n\nReturn the value of ul from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_uu-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_uu","text":"get_uu(LQDynamicData)\nget_uu(SparseLQDynamicModel)\nget_uu(DenseLQDynamicModel)\n\nReturn the value of uu from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.get_w-Tuple{LQDynamicData}","page":"API Manual","title":"DynamicNLPModels.get_w","text":"get_w(LQDynamicData)\nget_w(SparseLQDynamicModel)\nget_w(DenseLQDynamicModel)\n\nReturn the value of w from LQDynamicData or SparseLQDynamicModel.dynamic_data or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.reset_s0!-Union{Tuple{MK}, Tuple{M3}, Tuple{M2}, Tuple{M1}, Tuple{V}, Tuple{T}, Tuple{SparseLQDynamicModel{T, V, M1, M2, M3, MK}, V}} where {T, V<:AbstractVector{T}, M1, M2, M3, MK}","page":"API Manual","title":"DynamicNLPModels.reset_s0!","text":"reset_s0!(lqdm::SparseLQDynamicModel, s0)\nreset_s0!(lqdm::DenseLQDynamicModel, s0)\n\nResets s0 within lqdm.dynamic_data. For a SparseLQDynamicModel, this updates the variable bounds which fix the value of s0. For a DenseLQDynamicModel, also resets the constraint bounds on the Jacobian and resets the linear and constant terms within the objective function (i.e., lqdm.data.c and lqdm.data.c0). This provides a way to update the model after each sample period.\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_A!-Tuple{LQDynamicData, Any, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_A!","text":"set_A!(LQDynamicData, row, col, val)\nset_A!(SparseLQDynamicModel, row, col, val)\nset_A!(DenseLQDynamicModel, row, col, val)\n\nSet the value of entry A[row, col] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_B!-Tuple{LQDynamicData, Any, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_B!","text":"set_B!(LQDynamicData, row, col, val)\nset_B!(SparseLQDynamicModel, row, col, val)\nset_B!(DenseLQDynamicModel, row, col, val)\n\nSet the value of entry B[row, col] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_E!-Tuple{LQDynamicData, Any, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_E!","text":"set_E!(LQDynamicData, row, col, val)\nset_E!(SparseLQDynamicModel, row, col, val)\nset_E!(DenseLQDynamicModel, row, col, val)\n\nSet the value of entry E[row, col] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_F!-Tuple{LQDynamicData, Any, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_F!","text":"set_F!(LQDynamicData, row, col, val)\nset_F!(SparseLQDynamicModel, row, col, val)\nset_F!(DenseLQDynamicModel, row, col, val)\n\nSet the value of entry F[row, col] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_K!-Tuple{LQDynamicData, Any, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_K!","text":"set_K!(LQDynamicData, row, col, val)\nset_K!(SparseLQDynamicModel, row, col, val)\nset_K!(DenseLQDynamicModel, row, col, val)\n\nSet the value of entry K[row, col] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_Q!-Tuple{LQDynamicData, Any, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_Q!","text":"set_Q!(LQDynamicData, row, col, val)\nset_Q!(SparseLQDynamicModel, row, col, val)\nset_Q!(DenseLQDynamicModel, row, col, val)\n\nSet the value of entry Q[row, col] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_Qf!-Tuple{LQDynamicData, Any, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_Qf!","text":"set_Qf!(LQDynamicData, row, col, val)\nset_Qf!(SparseLQDynamicModel, row, col, val)\nset_Qf!(DenseLQDynamicModel, row, col, val)\n\nSet the value of entry Qf[row, col] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_R!-Tuple{LQDynamicData, Any, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_R!","text":"set_R!(LQDynamicData, row, col, val)\nset_R!(SparseLQDynamicModel, row, col, val)\nset_R!(DenseLQDynamicModel, row, col, val)\n\nSet the value of entry R[row, col] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_S!-Tuple{LQDynamicData, Any, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_S!","text":"set_S!(LQDynamicData, row, col, val)\nset_S!(SparseLQDynamicModel, row, col, val)\nset_S!(DenseLQDynamicModel, row, col, val)\n\nSet the value of entry S[row, col] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_gl!-Tuple{LQDynamicData, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_gl!","text":"set_gl!(LQDynamicData, index, val)\nset_gl!(SparseLQDynamicModel, index, val)\nset_gl!(DenseLQDynamicModel, index, val)\n\nSet the value of entry gl[index] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_gu!-Tuple{LQDynamicData, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_gu!","text":"set_gu!(LQDynamicData, index, val)\nset_gu!(SparseLQDynamicModel, index, val)\nset_gu!(DenseLQDynamicModel, index, val)\n\nSet the value of entry gu[index] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_s0!-Tuple{LQDynamicData, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_s0!","text":"set_s0!(LQDynamicData, index, val)\nset_s0!(SparseLQDynamicModel, index, val)\nset_s0!(DenseLQDynamicModel, index, val)\n\nSet the value of entry s0[index] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_sl!-Tuple{LQDynamicData, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_sl!","text":"set_sl!(LQDynamicData, index, val)\nset_sl!(SparseLQDynamicModel, index, val)\nset_sl!(DenseLQDynamicModel, index, val)\n\nSet the value of entry sl[index] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_su!-Tuple{LQDynamicData, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_su!","text":"set_su!(LQDynamicData, index, val)\nset_su!(SparseLQDynamicModel, index, val)\nset_su!(DenseLQDynamicModel, index, val)\n\nSet the value of entry su[index] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_ul!-Tuple{LQDynamicData, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_ul!","text":"set_ul!(LQDynamicData, index, val)\nset_ul!(SparseLQDynamicModel, index, val)\nset_ul!(DenseLQDynamicModel, index, val)\n\nSet the value of entry ul[index] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicNLPModels.set_uu!-Tuple{LQDynamicData, Any, Any}","page":"API Manual","title":"DynamicNLPModels.set_uu!","text":"set_uu!(LQDynamicData, index, val)\nset_uu!(SparseLQDynamicModel, index, val)\nset_uu!(DenseLQDynamicModel, index, val)\n\nSet the value of entry uu[index] to val for LQDynamicData, SparseLQDynamicModel.dynamic_data, or DenseLQDynamicModel.dynamic_data\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearOperators.reset!-Union{Tuple{DynamicNLPModels.LQJacobianOperator{T, M, A}}, Tuple{A}, Tuple{M}, Tuple{T}} where {T, M<:AbstractMatrix{T}, A<:AbstractMatrix{T}}","page":"API Manual","title":"LinearOperators.reset!","text":"LinearOperators.reset!(Jac::LQJacobianOperator{T, V, M})\n\nResets the values of attributes SJ1, SJ2, and SJ3 to zero\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DynamicNLPModels.jl is a package for Julia designed for representing linear model predictive control (MPC) problems. It includes an API for building a model from user defined data and querying solutions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis documentation is also available in PDF format.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To install this package, please use","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/MadNLP/DynamicNLPModels.jl.git\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/MadNLP/DynamicNLPModels.jl.git","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DynamicNLPModels.jl can construct both sparse and condensed formulations for MPC problems based on user defined data. We use the methods discussed by Jerez et al. to eliminate the states and condense the problem. DynamicNLPModels.jl constructs models that are subtypes of AbstractNLPModel from NLPModels.jl enabling both the sparse and condensed models to be solved with a variety of different solver packages in Julia. DynamicNLPModels was designed in part with the goal of solving linear MPC problems on the GPU. This can be done within MadNLP.jl using MadNLPGPU.jl. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The general sparse formulation used within DynamicNLPModels.jl is","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"beginaligned\nmin_s u v  s_N^top Q_f s_N + frac12 sum_i = 0^N-1 left beginarrayc s_i  u_i endarray right^top left beginarraycc Q  S  S^top  R endarray right left beginarrayc s_i  u_i endarray right\n          textrmst s_i+1 = As_i + Bu_i + w_i quad forall i = 0 1 cdots N - 1 \n           u_i = Ks_i + v_i quad  forall i = 0 1 cdots N - 1 \n           g^l le E s_i + F u_i le g^u quad forall i = 0 1 cdots N - 1\n           s^l le s_i le s^u quad forall i = 0 1 cdots N \n           u^l le u_t le u^u quad forall i = 0 1 cdots N - 1\n           s_0 = bars \nendaligned","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where s_i are the states, u_i are the inputs, N is the time horizon, bars are the initial states, and Q, R, A, and B are user defined data. The matrices Q_f, S, K, E, and F and the vectors w, g^l, g^u, s^l, s^u, u^l, and u^u are optional data. v_t is only needed in the condensed formulation, and it arises when K is defined by the user to ensure numerical stability of the condensed problem. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The condensed formulation used within DynamicNLPModels.jl is ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"beginaligned\nmin_boldsymbolv  frac12 boldsymbolv^top boldsymbolH boldsymbolv + boldsymbolh^top boldsymbolv + boldsymbolh_0\n        textrmst  d^l le boldsymbolJ boldsymbolv le d^u\nendaligned","category":"page"},{"location":"#Bug-reports-and-support","page":"Introduction","title":"Bug reports and support","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is new and still undergoing some development. If you encounter a bug, please report it through Github's issue tracker. ","category":"page"}]
}
